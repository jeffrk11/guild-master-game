package main.map;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

public class WaveFunctionMap {
    
    
    public static void main(String[] args) {
        
    }
    
    public static MapTiles[][] generateMapGrid(int width, int height){
        MapTiles[][] grid = new MapTiles[width][height];
        List<Tile> gridHistory = new ArrayList<>();
        try{
            while(gridHistory.size() < width*height){
                Tile nextTile = nextPosition(grid,gridHistory);
                List<MapTiles> possibilities  = checkPossibilities(nextTile, grid);
                nextTile.setTileType(possibilities.get(new Random().nextInt(possibilities.size())));
                gridHistory.add(nextTile);
                grid[nextTile.getX()][nextTile.getY()] = nextTile.getTileType();
                // printGrid(grid);
            }

        }catch(Exception e){
            return grid;
        }
        System.out.println("GENERATED");

        return grid;
    }
    private static List<MapTiles> checkPossibilities(Tile tile, MapTiles[][] grid){
        List<MapRule> rules = new LinkedList<>();
        int neighbours = 0;
        //add TOP
        if(tile.getX() -1 >= 0 && grid[tile.getX()-1][tile.getY()] != null){
            rules.addAll(List.of(grid[tile.getX()-1][tile.getY()].getRules()));
            neighbours++;
        }
        //add left
        if(tile.getY() -1 >= 0 && grid[tile.getX()][tile.getY()-1] != null){
            rules.addAll(List.of(grid[tile.getX()][tile.getY()-1].getRules()));
            neighbours++;
        }
        //add down
        if(tile.getX() + 1 < grid[0].length && grid[tile.getX()+1][tile.getY()] != null){
            rules.addAll(List.of(grid[tile.getX()+1][tile.getY()].getRules()));
            neighbours++;
        }
        //add right
        if(tile.getY() +1 < grid[1].length && grid[tile.getX()][tile.getY()+1] != null){
            rules.addAll(List.of(grid[tile.getX()][tile.getY()+1].getRules()));
            neighbours++;
        }

        //first
        if(neighbours == 0)
            return List.of(MapTiles.values());

        if(neighbours > 1){
            //filtrar os unicos e remover
            Map<String,Integer> countRules = new HashMap<>();
            for(MapRule rule : rules){
                countRules.put(rule.getMapTile(), countRules.getOrDefault(rule.getMapTile(), 0)+1);
            }
            for(Entry<String,Integer> entry : countRules.entrySet()){
                if(entry.getValue() == 1)
                    rules.removeIf( e-> e.getMapTile().equals(entry.getKey()));
            }
        }
        
        if(rules.size() == 0) //ERROR
            rules.add(MapRule.of("GRASS", 1));

        List<MapTiles> finalTiles = new LinkedList<>();
        for(MapRule rule : rules){
            for (int i = 0; i < rule.getPercentage(); i++) {
                finalTiles.add(MapTiles.valueOf(rule.getMapTile()));
            }
        }

        return finalTiles;
    }

    //get next position to be generated by the nearest and random
    private static Tile nextPosition(MapTiles[][] grid, List<Tile> gridHistory){
        if(gridHistory.isEmpty()){
            int x = new Random().nextInt(grid[0].length);
            int y = new Random().nextInt(grid[1].length);
            return new Tile(x , y);
        }

        while(true){
            Tile randomTile = gridHistory.get(new Random().nextInt(gridHistory.size()));
            //look up, if available
            if(randomTile.getX() -1 >= 0 && grid[randomTile.getX()-1][randomTile.getY()] == null)
                return new Tile(randomTile.getX()-1, randomTile.getY());
            //look left, if available
            else if(randomTile.getY() -1 >= 0 && grid[randomTile.getX()][randomTile.getY()-1] == null)
                return new Tile(randomTile.getX(), randomTile.getY()-1);
            //look down, if available
            else if(randomTile.getX() + 1 < grid[0].length && grid[randomTile.getX()+1][randomTile.getY()] == null)
                return new Tile(randomTile.getX()+1, randomTile.getY());
            //look right, if available
            else if(randomTile.getY() +1 < grid[1].length && grid[randomTile.getX()][randomTile.getY()+1] == null)
                return new Tile(randomTile.getX(), randomTile.getY()+1);
        }

        
    }

    private static void printGrid(MapTiles[][] grid){
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                System.out.print(grid[i][j]+" ");
            }
            System.out.println();
        }
    }
}
